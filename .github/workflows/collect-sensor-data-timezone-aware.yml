name: Timezone-Aware Sensor Data Collection

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:  # Allow manual triggers for testing

jobs:
  collect-data:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install node-fetch@2
      
      - name: Collect sensor data with timezone awareness
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node -e "
          const fetch = require('node-fetch');
          const http = require('http');
          
          async function collectSensorData() {
            console.log('üöÄ Starting timezone-aware sensor data collection...');
            
            // Initialize Supabase client
            const supabaseUrl = process.env.SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            
            // Get current time info
            const now = new Date();
            const localTimeString = now.toString();
            const timeZoneOffset = now.getTimezoneOffset();
            const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            
            console.log('üïê Time Information:');
            console.log(\`  UTC time: \${now.toISOString()}\`);
            console.log(\`  Local time: \${localTimeString}\`);
            console.log(\`  Timezone: \${timeZone}\`);
            console.log(\`  Offset from UTC: \${-timeZoneOffset/60} hours\`);
            
            // Get sensors from database
            const sensorsResponse = await fetch(\`\${supabaseUrl}/rest/v1/sensor_metadata?is_active=eq.true&select=*,stores(id,name,organization_id)\`, {
              headers: {
                'apikey': supabaseKey,
                'Authorization': \`Bearer \${supabaseKey}\`
              }
            });
            
            if (!sensorsResponse.ok) {
              throw new Error(\`Failed to fetch sensors: \${sensorsResponse.status}\`);
            }
            
            const sensors = await sensorsResponse.json();
            console.log(\`Found \${sensors.length} active sensors\`);
            
            const results = [];
            // For real-time data, we need to look at recent hours
            const threeHoursAgo = new Date(now.getTime() - 3 * 60 * 60 * 1000);
            
            // Format date for sensors (they might expect local time)
            const formatDate = (date) => {
              const pad = (n) => n.toString().padStart(2, '0');
              return \`\${date.getFullYear()}-\${pad(date.getMonth() + 1)}-\${pad(date.getDate())}-\${pad(date.getHours())}:\${pad(date.getMinutes())}:\${pad(date.getSeconds())}\`;
            };
            
            // Process each sensor
            for (const sensor of sensors) {
              console.log(\`\\nüì° Processing \${sensor.sensor_name}...\`);
              
              try {
                // Fetch data using http module
                const data = await new Promise((resolve, reject) => {
                  const path = \`/dataloader.cgi?dw=vcalogcsv&report_type=0&statistics_type=3&linetype=31&time_start=\${formatDate(threeHoursAgo)}&time_end=\${formatDate(now)}\`;
                  
                  const options = {
                    hostname: sensor.sensor_ip,
                    port: sensor.sensor_port,
                    path: path,
                    method: 'GET',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from('admin:grnl.2024').toString('base64')
                    },
                    timeout: 30000
                  };
                  
                  const req = http.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => data += chunk);
                    res.on('end', () => {
                      if (res.statusCode === 200) {
                        resolve(data);
                      } else {
                        reject(new Error(\`HTTP \${res.statusCode}: \${data}\`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  req.on('timeout', () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                  
                  req.end();
                });
                
                // Parse CSV data
                const records = parseCSV(data);
                console.log(\`  ‚úÖ Retrieved \${records.length} records\`);
                
                // Process all records
                let processedCount = 0;
                
                for (const record of records) {
                  // Convert sensor timestamp to UTC for storage
                  // Assume sensor returns local time
                  const localTimestamp = record.timestamp;
                  const utcTimestamp = new Date(localTimestamp.getTime() + (timeZoneOffset * 60 * 1000));
                  
                  // Skip if timestamp is in the future (comparing in UTC)
                  if (utcTimestamp > now) {
                    console.log(\`  ‚è≠Ô∏è  Skipping future timestamp: \${localTimestamp.toISOString()} (local) -> \${utcTimestamp.toISOString()} (UTC)\`);
                    continue;
                  }
                  
                  // Only process recent data (last 3 hours in UTC)
                  if (now.getTime() - utcTimestamp.getTime() > 3 * 60 * 60 * 1000) continue;
                  
                  // Prepare record data with UTC timestamps
                  const recordData = {
                    sensor_id: sensor.id,
                    organization_id: sensor.organization_id,
                    store_id: sensor.store_id,
                    timestamp: utcTimestamp.toISOString(),
                    end_time: new Date(utcTimestamp.getTime() + (59 * 60 * 1000) + (59 * 1000)).toISOString(), // Add 59:59
                    line1_in: record.line1_in,
                    line1_out: record.line1_out,
                    line2_in: record.line2_in,
                    line2_out: record.line2_out,
                    line3_in: record.line3_in,
                    line3_out: record.line3_out,
                    line4_in: record.line4_in,
                    line4_out: record.line4_out
                  };
                  
                  // First check if record exists
                  const checkResponse = await fetch(
                    \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${sensor.id}&timestamp=eq.\${utcTimestamp.toISOString()}&select=id\`,
                    {
                      headers: {
                        'apikey': supabaseKey,
                        'Authorization': \`Bearer \${supabaseKey}\`
                      }
                    }
                  );
                  
                  const existing = await checkResponse.json();
                  
                  if (existing && existing.length > 0) {
                    // Record exists, update it
                    const updateResponse = await fetch(
                      \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${sensor.id}&timestamp=eq.\${utcTimestamp.toISOString()}\`,
                      {
                        method: 'PATCH',
                        headers: {
                          'apikey': supabaseKey,
                          'Authorization': \`Bearer \${supabaseKey}\`,
                          'Content-Type': 'application/json',
                          'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                          line1_in: record.line1_in,
                          line1_out: record.line1_out,
                          line2_in: record.line2_in,
                          line2_out: record.line2_out,
                          line3_in: record.line3_in,
                          line3_out: record.line3_out,
                          line4_in: record.line4_in,
                          line4_out: record.line4_out
                        })
                      }
                    );
                    
                    if (updateResponse.ok) {
                      console.log(\`  üìù Updated \${localTimestamp.toISOString()} (local) -> \${utcTimestamp.toISOString()} (UTC)\`);
                    }
                  } else {
                    // Record doesn't exist, insert it
                    const insertResponse = await fetch(\`\${supabaseUrl}/rest/v1/people_counting_raw\`, {
                      method: 'POST',
                      headers: {
                        'apikey': supabaseKey,
                        'Authorization': \`Bearer \${supabaseKey}\`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                      },
                      body: JSON.stringify(recordData)
                    });
                    
                    if (insertResponse.ok) {
                      console.log(\`  ‚ûï Inserted \${localTimestamp.toISOString()} (local) -> \${utcTimestamp.toISOString()} (UTC)\`);
                    }
                  }
                  
                  processedCount++;
                  
                  // Log current hour data
                  const totalIn = record.line1_in + record.line2_in + record.line3_in + record.line4_in;
                  const totalOut = record.line1_out + record.line2_out + record.line3_out + record.line4_out;
                  console.log(\`     üìä Data: \${totalIn} IN, \${totalOut} OUT\`);
                }
                
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'success',
                  records_processed: records.length,
                  records_updated: processedCount
                });
                
              } catch (error) {
                console.error(\`  ‚ùå Error: \${error.message}\`);
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'error',
                  error: error.message
                });
              }
            }
            
            // Summary
            console.log('\\nüìä Collection Summary:');
            console.log('====================');
            results.forEach(r => {
              const status = r.status === 'success' ? '‚úÖ' : '‚ùå';
              console.log(\`\${status} \${r.sensor}: \${r.status} (\${r.records_updated || 0} records processed)\`);
            });
            
            return results;
          }
          
          function parseCSV(csv) {
            const lines = csv.trim().split('\\n');
            if (lines.length < 2) return [];
            
            const records = [];
            
            // Skip header, process data lines
            for (let i = 1; i < lines.length; i++) {
              const parts = lines[i].split(',').map(p => p.trim());
              
              if (parts.length >= 17) {
                try {
                  // Parse timestamp - sensor might return local time
                  const timestamp = new Date(parts[0].replace(/\\//g, '-'));
                  
                  records.push({
                    timestamp: timestamp,
                    endTime: new Date(parts[1].replace(/\\//g, '-')),
                    line1_in: parseInt(parts[5]) || 0,
                    line1_out: parseInt(parts[6]) || 0,
                    line2_in: parseInt(parts[8]) || 0,
                    line2_out: parseInt(parts[9]) || 0,
                    line3_in: parseInt(parts[11]) || 0,
                    line3_out: parseInt(parts[12]) || 0,
                    line4_in: parseInt(parts[14]) || 0,
                    line4_out: parseInt(parts[15]) || 0
                  });
                } catch (e) {
                  console.error('Error parsing line:', lines[i]);
                }
              }
            }
            
            return records;
          }
          
          // Run the collection
          collectSensorData()
            .then(() => {
              console.log('\\n‚úÖ Data collection completed successfully!');
              process.exit(0);
            })
            .catch((error) => {
              console.error('\\n‚ùå Data collection failed:', error);
              process.exit(1);
            });
          "
      
      - name: Send notification on failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Sensor data collection failed. Check the logs for details."