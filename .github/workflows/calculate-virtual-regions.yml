name: Calculate Virtual Regions

on:
  schedule:
    # Run every 30 minutes to calculate virtual regions from line crossing data
    - cron: '10,40 * * * *'
  workflow_dispatch:  # Allow manual triggers

jobs:
  calculate-virtual-regions:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install node-fetch@2
      
      - name: Calculate virtual regions for Milesight sensor
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node -e "
          const fetch = require('node-fetch');
          
          async function calculateVirtualRegions() {
            console.log('üó∫Ô∏è  Starting Virtual Region Calculation...');
            console.log(\`üìÖ Current UTC time: \${new Date().toISOString()}\`);
            
            const supabaseUrl = process.env.SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            
            // Milesight sensor that needs virtual regions
            const milesightSensor = {
              id: '4ccdc18a-5e3f-48e8-a069-3876e14eb7d4',
              name: 'J&J Store - People Counter',
              regions: {
                region1: { name: 'Store Entrance', lines: ['line1'] },
                region2: { name: 'Main Shopping Area', lines: ['line2', 'line3'] },
                region3: { name: 'Checkout Zone', lines: ['line2'] },
                region4: { name: 'Window Display', lines: ['line4'] }
              }
            };
            
            try {
              // Get the last 30 minutes of raw data
              const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();
              
              console.log('\\nüì• Fetching recent line crossing data...');
              const rawDataResponse = await fetch(
                \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${milesightSensor.id}&timestamp=gte.\${thirtyMinutesAgo}&order=timestamp.asc\`,
                {
                  headers: {
                    'apikey': supabaseKey,
                    'Authorization': \`Bearer \${supabaseKey}\`
                  }
                }
              );
              
              if (!rawDataResponse.ok) {
                throw new Error(\`Failed to fetch raw data: \${rawDataResponse.status}\`);
              }
              
              const rawData = await rawDataResponse.json();
              console.log(\`  ‚úÖ Found \${rawData.length} raw data records\`);
              
              if (rawData.length === 0) {
                console.log('  ‚ÑπÔ∏è  No new data to process');
                return;
              }
              
              // Get existing region configurations
              const regionConfigResponse = await fetch(
                \`\${supabaseUrl}/rest/v1/region_configurations?sensor_id=eq.\${milesightSensor.id}\`,
                {
                  headers: {
                    'apikey': supabaseKey,
                    'Authorization': \`Bearer \${supabaseKey}\`
                  }
                }
              );
              
              const regionConfigs = await regionConfigResponse.json();
              const regionMap = {};
              regionConfigs.forEach(config => {
                const regionNum = config.name.match(/region(\\d+)/i)?.[1];
                if (regionNum) {
                  regionMap[\`region\${regionNum}\`] = config.id;
                }
              });
              
              // Calculate virtual regions from line crossings
              console.log('\\nüßÆ Calculating virtual regions...');
              const regionalData = [];
              const occupancyByRegion = {
                region1: 0,
                region2: 0,
                region3: 0,
                region4: 0
              };
              
              // Process each timestamp
              const timestampGroups = {};
              rawData.forEach(record => {
                const timestamp = record.timestamp;
                if (!timestampGroups[timestamp]) {
                  timestampGroups[timestamp] = {
                    line1_in: 0, line1_out: 0,
                    line2_in: 0, line2_out: 0,
                    line3_in: 0, line3_out: 0,
                    line4_in: 0, line4_out: 0
                  };
                }
                
                // Extract line number and direction from the data
                const data = record.data || {};
                Object.entries(data).forEach(([key, value]) => {
                  if (key.match(/line\\d+_(in|out)/i)) {
                    timestampGroups[timestamp][key.toLowerCase()] = parseInt(value) || 0;
                  }
                });
              });
              
              // Calculate regional occupancy changes
              Object.entries(timestampGroups).forEach(([timestamp, lines]) => {
                // Region 1 (Entrance): Line1 traffic
                const region1_entries = lines.line1_in || 0;
                const region1_exits = lines.line1_out || 0;
                occupancyByRegion.region1 += (region1_entries - region1_exits);
                
                // Region 2 (Shopping): Line2 + Line3 combined
                const region2_entries = (lines.line2_in || 0) + (lines.line3_in || 0);
                const region2_exits = (lines.line2_out || 0) + (lines.line3_out || 0);
                occupancyByRegion.region2 += (region2_entries - region2_exits);
                
                // Region 3 (Checkout): Line2 only
                const region3_entries = lines.line2_in || 0;
                const region3_exits = lines.line2_out || 0;
                occupancyByRegion.region3 += (region3_entries - region3_exits);
                
                // Region 4 (Window): Line4 traffic (bidirectional)
                const region4_traffic = (lines.line4_in || 0) + (lines.line4_out || 0);
                
                // Create regional analytics records
                Object.entries(occupancyByRegion).forEach(([regionKey, occupancy]) => {
                  const regionNum = regionKey.replace('region', '');
                  const regionId = regionMap[regionKey];
                  
                  if (regionId && (regionKey === 'region4' ? region4_traffic > 0 : true)) {
                    regionalData.push({
                      region_id: regionId,
                      timestamp: timestamp,
                      occupancy_count: Math.max(0, occupancy),
                      entries: regionKey === \`region\${regionNum}\` ? 
                        (regionNum === '1' ? region1_entries :
                         regionNum === '2' ? region2_entries :
                         regionNum === '3' ? region3_entries : region4_traffic) : 0,
                      exits: regionKey === \`region\${regionNum}\` ?
                        (regionNum === '1' ? region1_exits :
                         regionNum === '2' ? region2_exits :
                         regionNum === '3' ? region3_exits : 0) : 0,
                      dwell_time_seconds: null // Calculate in aggregation
                    });
                  }
                });
              });
              
              if (regionalData.length > 0) {
                console.log(\`\\nüìä Calculated data for \${regionalData.length} regional events\`);
                console.log('  Current occupancy estimates:');
                Object.entries(occupancyByRegion).forEach(([region, count]) => {
                  console.log(\`    - \${region}: \${Math.max(0, count)} people\`);
                });
                
                // Insert regional analytics data
                console.log('\\nüíæ Inserting regional analytics...');
                const insertResponse = await fetch(\`\${supabaseUrl}/rest/v1/regional_analytics\`, {
                  method: 'POST',
                  headers: {
                    'apikey': supabaseKey,
                    'Authorization': \`Bearer \${supabaseKey}\`,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=minimal'
                  },
                  body: JSON.stringify(regionalData)
                });
                
                if (insertResponse.ok) {
                  console.log('  ‚úÖ Regional analytics inserted successfully');
                  
                  // Update occupancy snapshots
                  const snapshots = Object.entries(occupancyByRegion).map(([regionKey, count]) => ({
                    region_id: regionMap[regionKey],
                    current_occupancy: Math.max(0, count),
                    last_updated: new Date().toISOString()
                  })).filter(s => s.region_id);
                  
                  const snapshotResponse = await fetch(\`\${supabaseUrl}/rest/v1/regional_occupancy_snapshots\`, {
                    method: 'POST',
                    headers: {
                      'apikey': supabaseKey,
                      'Authorization': \`Bearer \${supabaseKey}\`,
                      'Content-Type': 'application/json',
                      'Prefer': 'return=minimal,resolution=merge-duplicates'
                    },
                    body: JSON.stringify(snapshots)
                  });
                  
                  if (snapshotResponse.ok) {
                    console.log('  ‚úÖ Occupancy snapshots updated');
                  } else {
                    console.error('  ‚ö†Ô∏è  Failed to update occupancy snapshots');
                  }
                  
                } else {
                  const error = await insertResponse.text();
                  console.error(\`  ‚ùå Failed to insert regional data: \${error}\`);
                }
              } else {
                console.log('  ‚ÑπÔ∏è  No regional events to record');
              }
              
            } catch (error) {
              console.error('\\n‚ùå Error calculating virtual regions:', error.message);
              process.exit(1);
            }
            
            console.log('\\n‚úÖ Virtual region calculation completed!');
          }
          
          // Run the calculation
          calculateVirtualRegions()
            .then(() => process.exit(0))
            .catch((error) => {
              console.error('‚ùå Virtual region calculation failed:', error);
              process.exit(1);
            });
          "