name: Smart Sensor Data Collection

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:  # Allow manual triggers for testing

jobs:
  collect-data:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install node-fetch@2
      
      - name: Collect sensor data intelligently
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node -e "
          const fetch = require('node-fetch');
          const http = require('http');
          
          async function collectSensorData() {
            console.log('üöÄ Starting smart sensor data collection...');
            
            // Initialize Supabase client
            const supabaseUrl = process.env.SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            
            // Get current UTC time
            const nowUTC = new Date();
            console.log(\`üìÖ Current UTC time: \${nowUTC.toISOString()}\`);
            
            // Get sensors from database
            const sensorsResponse = await fetch(\`\${supabaseUrl}/rest/v1/sensor_metadata?is_active=eq.true&select=*,stores(id,name,organization_id)\`, {
              headers: {
                'apikey': supabaseKey,
                'Authorization': \`Bearer \${supabaseKey}\`
              }
            });
            
            if (!sensorsResponse.ok) {
              throw new Error(\`Failed to fetch sensors: \${sensorsResponse.status}\`);
            }
            
            const sensors = await sensorsResponse.json();
            console.log(\`Found \${sensors.length} active sensors\\n\`);
            
            const results = [];
            
            // Process each sensor
            for (const sensor of sensors) {
              console.log(\`üì° Processing \${sensor.sensor_name}...\`);
              
              try {
                // First, probe the sensor to understand its time behavior
                const probeData = await probeSensorTime(sensor);
                console.log(\`  üïê Sensor timezone offset: \${probeData.offsetHours} hours from UTC\`);
                
                // Calculate the query range in sensor's local time
                const sensorNow = new Date(nowUTC.getTime() - (probeData.offsetHours * 60 * 60 * 1000));
                const sensorThreeHoursAgo = new Date(sensorNow.getTime() - 3 * 60 * 60 * 1000);
                
                // Format date for sensors (in their local time)
                const formatDate = (date) => {
                  const pad = (n) => n.toString().padStart(2, '0');
                  return \`\${date.getFullYear()}-\${pad(date.getMonth() + 1)}-\${pad(date.getDate())}-\${pad(date.getHours())}:\${pad(date.getMinutes())}:\${pad(date.getSeconds())}\`;
                };
                
                // Fetch data from sensor
                const data = await new Promise((resolve, reject) => {
                  const path = \`/dataloader.cgi?dw=vcalogcsv&report_type=0&statistics_type=3&linetype=31&time_start=\${formatDate(sensorThreeHoursAgo)}&time_end=\${formatDate(sensorNow)}\`;
                  
                  const options = {
                    hostname: sensor.sensor_ip,
                    port: sensor.sensor_port,
                    path: path,
                    method: 'GET',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from('admin:grnl.2024').toString('base64')
                    },
                    timeout: 30000
                  };
                  
                  const req = http.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => data += chunk);
                    res.on('end', () => {
                      if (res.statusCode === 200) {
                        resolve(data);
                      } else {
                        reject(new Error(\`HTTP \${res.statusCode}: \${data}\`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  req.on('timeout', () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                  
                  req.end();
                });
                
                // Parse CSV data
                const records = parseCSV(data, probeData.offsetHours);
                console.log(\`  ‚úÖ Retrieved \${records.length} records\`);
                
                // Process records
                let processedCount = 0;
                
                for (const record of records) {
                  // Skip future data (in UTC)
                  if (record.utcTimestamp > nowUTC) {
                    continue;
                  }
                  
                  // Only process recent data (last 3 hours in UTC)
                  if (nowUTC.getTime() - record.utcTimestamp.getTime() > 3 * 60 * 60 * 1000) {
                    continue;
                  }
                  
                  // Prepare record data
                  const recordData = {
                    sensor_id: sensor.id,
                    organization_id: sensor.organization_id,
                    store_id: sensor.store_id,
                    timestamp: record.utcTimestamp.toISOString(),
                    end_time: record.utcEndTime.toISOString(),
                    line1_in: record.line1_in,
                    line1_out: record.line1_out,
                    line2_in: record.line2_in,
                    line2_out: record.line2_out,
                    line3_in: record.line3_in,
                    line3_out: record.line3_out,
                    line4_in: record.line4_in,
                    line4_out: record.line4_out
                  };
                  
                  // Check if record exists
                  const checkResponse = await fetch(
                    \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${sensor.id}&timestamp=eq.\${record.utcTimestamp.toISOString()}&select=id\`,
                    {
                      headers: {
                        'apikey': supabaseKey,
                        'Authorization': \`Bearer \${supabaseKey}\`
                      }
                    }
                  );
                  
                  const existing = await checkResponse.json();
                  
                  if (existing && existing.length > 0) {
                    // Update existing record
                    const updateResponse = await fetch(
                      \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${sensor.id}&timestamp=eq.\${record.utcTimestamp.toISOString()}\`,
                      {
                        method: 'PATCH',
                        headers: {
                          'apikey': supabaseKey,
                          'Authorization': \`Bearer \${supabaseKey}\`,
                          'Content-Type': 'application/json',
                          'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                          line1_in: record.line1_in,
                          line1_out: record.line1_out,
                          line2_in: record.line2_in,
                          line2_out: record.line2_out,
                          line3_in: record.line3_in,
                          line3_out: record.line3_out,
                          line4_in: record.line4_in,
                          line4_out: record.line4_out
                        })
                      }
                    );
                    
                    if (updateResponse.ok) {
                      const totalIn = record.line1_in + record.line2_in + record.line3_in + record.line4_in;
                      const totalOut = record.line1_out + record.line2_out + record.line3_out + record.line4_out;
                      console.log(\`  üìù Updated \${record.utcTimestamp.toISOString().slice(11,16)} UTC: \${totalIn} IN, \${totalOut} OUT\`);
                    }
                  } else {
                    // Insert new record
                    const insertResponse = await fetch(\`\${supabaseUrl}/rest/v1/people_counting_raw\`, {
                      method: 'POST',
                      headers: {
                        'apikey': supabaseKey,
                        'Authorization': \`Bearer \${supabaseKey}\`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                      },
                      body: JSON.stringify(recordData)
                    });
                    
                    if (insertResponse.ok) {
                      const totalIn = record.line1_in + record.line2_in + record.line3_in + record.line4_in;
                      const totalOut = record.line1_out + record.line2_out + record.line3_out + record.line4_out;
                      console.log(\`  ‚ûï Inserted \${record.utcTimestamp.toISOString().slice(11,16)} UTC: \${totalIn} IN, \${totalOut} OUT\`);
                    }
                  }
                  
                  processedCount++;
                }
                
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'success',
                  records_processed: records.length,
                  records_updated: processedCount
                });
                
              } catch (error) {
                console.error(\`  ‚ùå Error: \${error.message}\`);
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'error',
                  error: error.message
                });
              }
            }
            
            // Summary
            console.log('\\nüìä Collection Summary:');
            console.log('====================');
            results.forEach(r => {
              const status = r.status === 'success' ? '‚úÖ' : '‚ùå';
              console.log(\`\${status} \${r.sensor}: \${r.status} (\${r.records_updated || 0} records processed)\`);
            });
            
            return results;
          }
          
          async function probeSensorTime(sensor) {
            // Get a small sample of data to determine timezone offset
            const nowUTC = new Date();
            const oneHourAgo = new Date(nowUTC.getTime() - 60 * 60 * 1000);
            
            const formatDate = (date) => {
              const pad = (n) => n.toString().padStart(2, '0');
              return \`\${date.getFullYear()}-\${pad(date.getMonth() + 1)}-\${pad(date.getDate())}-\${pad(date.getHours())}:\${pad(date.getMinutes())}:\${pad(date.getSeconds())}\`;
            };
            
            try {
              const data = await new Promise((resolve, reject) => {
                const path = \`/dataloader.cgi?dw=vcalogcsv&report_type=0&statistics_type=3&linetype=31&time_start=\${formatDate(oneHourAgo)}&time_end=\${formatDate(nowUTC)}\`;
                
                const options = {
                  hostname: sensor.sensor_ip,
                  port: sensor.sensor_port,
                  path: path,
                  method: 'GET',
                  headers: {
                    'Authorization': 'Basic ' + Buffer.from('admin:grnl.2024').toString('base64')
                  },
                  timeout: 10000
                };
                
                const req = require('http').request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => data += chunk);
                  res.on('end', () => resolve(data));
                });
                
                req.on('error', reject);
                req.on('timeout', () => {
                  req.destroy();
                  reject(new Error('Probe timeout'));
                });
                
                req.end();
              });
              
              // Parse the response to detect timezone
              const lines = data.trim().split('\\n');
              if (lines.length > 1) {
                const parts = lines[1].split(',');
                if (parts.length >= 17) {
                  const sensorTime = new Date(parts[0].replace(/\\//g, '-'));
                  
                  // Check for data with non-zero values to determine actual current time
                  for (let i = 1; i < lines.length; i++) {
                    const p = lines[i].split(',');
                    if (p.length >= 17) {
                      const totalIn = parseInt(p[5]||0) + parseInt(p[8]||0) + parseInt(p[11]||0) + parseInt(p[14]||0);
                      if (totalIn > 0) {
                        const activeTime = new Date(p[0].replace(/\\//g, '-'));
                        // Compare with UTC to estimate offset
                        const hourDiff = Math.round((activeTime.getHours() - nowUTC.getHours()));
                        if (hourDiff >= -12 && hourDiff <= 12) {
                          return { offsetHours: -hourDiff };
                        }
                      }
                    }
                  }
                }
              }
            } catch (e) {
              console.log(\`    ‚ö†Ô∏è  Could not probe sensor time: \${e.message}\`);
            }
            
            // Default: assume UTC
            return { offsetHours: 0 };
          }
          
          function parseCSV(csv, offsetHours = 0) {
            const lines = csv.trim().split('\\n');
            if (lines.length < 2) return [];
            
            const records = [];
            
            // Skip header, process data lines
            for (let i = 1; i < lines.length; i++) {
              const parts = lines[i].split(',').map(p => p.trim());
              
              if (parts.length >= 17) {
                try {
                  // Parse timestamp as sensor local time
                  const sensorTimestamp = new Date(parts[0].replace(/\\//g, '-'));
                  const sensorEndTime = new Date(parts[1].replace(/\\//g, '-'));
                  
                  // Convert to UTC by applying offset
                  const utcTimestamp = new Date(sensorTimestamp.getTime() + (offsetHours * 60 * 60 * 1000));
                  const utcEndTime = new Date(sensorEndTime.getTime() + (offsetHours * 60 * 60 * 1000));
                  
                  records.push({
                    sensorTimestamp: sensorTimestamp,
                    utcTimestamp: utcTimestamp,
                    utcEndTime: utcEndTime,
                    line1_in: parseInt(parts[5]) || 0,
                    line1_out: parseInt(parts[6]) || 0,
                    line2_in: parseInt(parts[8]) || 0,
                    line2_out: parseInt(parts[9]) || 0,
                    line3_in: parseInt(parts[11]) || 0,
                    line3_out: parseInt(parts[12]) || 0,
                    line4_in: parseInt(parts[14]) || 0,
                    line4_out: parseInt(parts[15]) || 0
                  });
                } catch (e) {
                  console.error('Error parsing line:', lines[i]);
                }
              }
            }
            
            return records;
          }
          
          // Run the collection
          collectSensorData()
            .then(() => {
              console.log('\\n‚úÖ Data collection completed successfully!');
              process.exit(0);
            })
            .catch((error) => {
              console.error('\\n‚ùå Data collection failed:', error);
              process.exit(1);
            });
          "
      
      - name: Send notification on failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Sensor data collection failed. Check the logs for details."