name: Direct Sensor Data Collection

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:  # Allow manual triggers for testing

jobs:
  collect-data:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install node-fetch@2
      
      - name: Collect sensor data and store in Supabase
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node -e "
          const fetch = require('node-fetch');
          const http = require('http');
          
          async function collectSensorData() {
            console.log('üöÄ Starting direct sensor data collection...');
            
            // Initialize Supabase client
            const supabaseUrl = process.env.SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            
            // Get sensors from database
            const sensorsResponse = await fetch(\`\${supabaseUrl}/rest/v1/sensor_metadata?is_active=eq.true&select=*,stores(id,name,organization_id)\`, {
              headers: {
                'apikey': supabaseKey,
                'Authorization': \`Bearer \${supabaseKey}\`
              }
            });
            
            if (!sensorsResponse.ok) {
              throw new Error(\`Failed to fetch sensors: \${sensorsResponse.status}\`);
            }
            
            const sensors = await sensorsResponse.json();
            console.log(\`Found \${sensors.length} active sensors\`);
            
            const results = [];
            const now = new Date();
            const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000);
            
            // Format date for sensors
            const formatDate = (date) => {
              const pad = (n) => n.toString().padStart(2, '0');
              return \`\${date.getFullYear()}-\${pad(date.getMonth() + 1)}-\${pad(date.getDate())}-\${pad(date.getHours())}:\${pad(date.getMinutes())}:\${pad(date.getSeconds())}\`;
            };
            
            // Process each sensor
            for (const sensor of sensors) {
              console.log(\`\\nüì° Processing \${sensor.sensor_name}...\`);
              
              try {
                // Fetch data using http module (works better with sensors)
                const data = await new Promise((resolve, reject) => {
                  const path = \`/dataloader.cgi?dw=vcalogcsv&report_type=0&statistics_type=3&linetype=31&time_start=\${formatDate(twoHoursAgo)}&time_end=\${formatDate(now)}\`;
                  
                  const options = {
                    hostname: sensor.sensor_ip,
                    port: sensor.sensor_port,
                    path: path,
                    method: 'GET',
                    headers: {
                      'Authorization': 'Basic ' + Buffer.from('admin:grnl.2024').toString('base64')
                    },
                    timeout: 30000
                  };
                  
                  const req = http.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => data += chunk);
                    res.on('end', () => {
                      if (res.statusCode === 200) {
                        resolve(data);
                      } else {
                        reject(new Error(\`HTTP \${res.statusCode}: \${data}\`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  req.on('timeout', () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                  
                  req.end();
                });
                
                // Parse CSV data
                const records = parseCSV(data);
                console.log(\`  ‚úÖ Retrieved \${records.length} records\`);
                
                // Get last timestamp for this sensor
                const lastRecordResponse = await fetch(
                  \`\${supabaseUrl}/rest/v1/people_counting_raw?sensor_id=eq.\${sensor.id}&select=timestamp&order=timestamp.desc&limit=1\`,
                  {
                    headers: {
                      'apikey': supabaseKey,
                      'Authorization': \`Bearer \${supabaseKey}\`
                    }
                  }
                );
                
                const lastRecordData = await lastRecordResponse.json();
                const lastTimestamp = lastRecordData[0]?.timestamp ? new Date(lastRecordData[0].timestamp) : null;
                
                // Filter and insert new records
                let inserted = 0;
                const recordsToInsert = [];
                
                for (const record of records) {
                  // Skip future data
                  if (record.timestamp > now) continue;
                  
                  // Skip old data
                  if (now.getTime() - record.timestamp.getTime() > 2 * 60 * 60 * 1000) continue;
                  
                  // Skip if already collected
                  if (lastTimestamp && record.timestamp <= lastTimestamp) continue;
                  
                  // Log zero data but don't skip - stores might genuinely have no traffic
                  const totalMovement = record.line1_in + record.line1_out + record.line2_in + record.line2_out +
                                       record.line3_in + record.line3_out + record.line4_in + record.line4_out;
                  if (totalMovement === 0) {
                    console.log(`  ‚ö†Ô∏è  Zero movement data for ${record.timestamp.toISOString()}`);
                  }
                  
                  recordsToInsert.push({
                    sensor_id: sensor.id,
                    organization_id: sensor.organization_id,
                    store_id: sensor.store_id,
                    timestamp: record.timestamp.toISOString(),
                    end_time: record.endTime.toISOString(),
                    line1_in: record.line1_in,
                    line1_out: record.line1_out,
                    line2_in: record.line2_in,
                    line2_out: record.line2_out,
                    line3_in: record.line3_in,
                    line3_out: record.line3_out,
                    line4_in: record.line4_in,
                    line4_out: record.line4_out
                  });
                }
                
                // Batch insert records
                if (recordsToInsert.length > 0) {
                  const insertResponse = await fetch(\`\${supabaseUrl}/rest/v1/people_counting_raw\`, {
                    method: 'POST',
                    headers: {
                      'apikey': supabaseKey,
                      'Authorization': \`Bearer \${supabaseKey}\`,
                      'Content-Type': 'application/json',
                      'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify(recordsToInsert)
                  });
                  
                  if (insertResponse.ok) {
                    inserted = recordsToInsert.length;
                    console.log(\`  ‚úÖ Inserted \${inserted} new records\`);
                  } else {
                    console.error(\`  ‚ùå Insert failed: \${insertResponse.status}\`);
                  }
                }
                
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'success',
                  records_processed: records.length,
                  records_inserted: inserted
                });
                
              } catch (error) {
                console.error(\`  ‚ùå Error: \${error.message}\`);
                results.push({
                  sensor: sensor.sensor_name,
                  status: 'error',
                  error: error.message
                });
              }
            }
            
            // Summary
            console.log('\\nüìä Collection Summary:');
            console.log('====================');
            results.forEach(r => {
              const status = r.status === 'success' ? '‚úÖ' : '‚ùå';
              console.log(\`\${status} \${r.sensor}: \${r.status} (\${r.records_inserted || 0} records inserted)\`);
            });
            
            return results;
          }
          
          function parseCSV(csv) {
            const lines = csv.trim().split('\\n');
            if (lines.length < 2) return [];
            
            const records = [];
            
            // Skip header, process data lines
            for (let i = 1; i < lines.length; i++) {
              const parts = lines[i].split(',').map(p => p.trim());
              
              if (parts.length >= 17) {
                try {
                  records.push({
                    timestamp: new Date(parts[0].replace(/\\//g, '-')),
                    endTime: new Date(parts[1].replace(/\\//g, '-')),
                    line1_in: parseInt(parts[5]) || 0,
                    line1_out: parseInt(parts[6]) || 0,
                    line2_in: parseInt(parts[8]) || 0,
                    line2_out: parseInt(parts[9]) || 0,
                    line3_in: parseInt(parts[11]) || 0,
                    line3_out: parseInt(parts[12]) || 0,
                    line4_in: parseInt(parts[14]) || 0,
                    line4_out: parseInt(parts[15]) || 0
                  });
                } catch (e) {
                  console.error('Error parsing line:', lines[i]);
                }
              }
            }
            
            return records;
          }
          
          // Run the collection
          collectSensorData()
            .then(() => {
              console.log('\\n‚úÖ Data collection completed successfully!');
              process.exit(0);
            })
            .catch((error) => {
              console.error('\\n‚ùå Data collection failed:', error);
              process.exit(1);
            });
          "
      
      - name: Send notification on failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Sensor data collection failed. Check the logs for details."